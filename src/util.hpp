#pragma once

#include "markov_process.hpp"

//===----------------------------------------------------------------------===//
/// Populate the given range with random integers (uniform).
template<typename It>
static void
gen_data_uniform(It begin, It end) {
  std::random_device rnd_device;
  std::mt19937 gen(rnd_device());
  std::uniform_int_distribution<amsfilter::key_t> dis;

  for (auto it = begin; it != end; ++it) {
    *it = dis(gen);
  }
}
//===----------------------------------------------------------------------===//
/// Populate the given range with random integers generated by a Markov process.
/// The generated integer are within [0,k). The parameter f refers to the
/// clustering factor which is the average number of consecutive identical
/// integers.
template<typename It>
static void
gen_data_markov(It begin, It end, u32 k, f64 f) {
  markov_process mp(k, f);
  for (auto it = begin; it != end; ++it) {
    *it = mp.next();
  }
}
//===----------------------------------------------------------------------===//
/// Parse the filter configuration.
static amsfilter::Config
parse_filter_config(const std::string config_str) {
  typedef boost::tokenizer<boost::char_separator<char>> tokenizer;
  boost::char_separator<char> sep{","};
  tokenizer tok{config_str, sep};
  auto tok_it = tok.begin();

  // The filter parameters.
  amsfilter::Config config;
  config.word_cnt_per_block = u32(std::stoul(*tok_it)); tok_it++;
  config.sector_cnt = u32(std::stoul(*tok_it)); tok_it++;
  config.zone_cnt = u32(std::stoul(*tok_it)); tok_it++;
  config.k = u32(std::stoul(*tok_it)); tok_it++;
  return config;
}
//===----------------------------------------------------------------------===//
/// Parse the data generation parameters, which could be
/// - uniform
/// - markov,f
enum class data_dist { UNIFORM, MARKOV };
struct data_gen_config {
  data_dist dist;
  $f64 clustering_factor;
};
static data_gen_config
parse_datagen_config(const std::string config_str) {
  typedef boost::tokenizer<boost::char_separator<char>> tokenizer;
  boost::char_separator<char> sep{","};
  tokenizer tok{config_str, sep};
  auto tok_it = tok.begin();

  data_gen_config ret_val;
  if (*tok_it == "uniform") {
    ret_val.dist = data_dist::UNIFORM;
  }
  else if (*tok_it == "markov") {
    ret_val.dist = data_dist::MARKOV;
    tok_it++;
    ret_val.clustering_factor = std::stod(*tok_it);
  }
  else {
    throw std::invalid_argument("Unknown distribution.");
  }
  return ret_val;
}
//===----------------------------------------------------------------------===//
/// Populate the given range with random integers (uniform).
template<typename It>
static void
gen_data(It begin, It end, const data_gen_config& config) {
  switch (config.dist) {
    case data_dist::UNIFORM:
      gen_data_uniform(begin, end);
      break;
    case data_dist::MARKOV:
      if (config.clustering_factor < 1) {
        throw std::invalid_argument(
            "The clustering factor must not be less than 1.0.");
      }
      f64 f_desired = config.clustering_factor;
      f64 max_error = f_desired * 0.02; // 2%
      const std::size_t max_tries = 1000;
      for (std::size_t i = 0; i < max_tries; ++i) {
        gen_data_markov(begin, end,
            std::numeric_limits<$i32>::max(), config.clustering_factor);
        f64 f_actual = determine_clustering_factor(begin, end);
        if (f_actual >= (f_desired - max_error)
            && f_actual <= (f_desired + max_error)) {
          return;
        }
      }
      throw std::runtime_error(
          "Failed to generate random data within error bounds.");
  }
}
//===----------------------------------------------------------------------===//
#if defined(HAVE_CUDA) || defined(__CUDACC__)
static std::string
get_cuda_device_name(u32 cuda_device_no) {
  cudaDeviceProp device_prop;
  cudaGetDeviceProperties(&device_prop, cuda_device_no);
  return std::string(device_prop.name);
}
#endif
//===----------------------------------------------------------------------===//
